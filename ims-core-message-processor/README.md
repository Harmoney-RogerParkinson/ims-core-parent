#ims-core-message-processor

The role of the Message Processor is to receive messages from the [bayeux](https://en.wikipedia.org/wiki/Comet_(programming)) queue generated by Salesforce triggers which fire when new records/objects are created in the Salesforce database.

Messages describe the new record and the Message Processor gives them an initial check before saving them into a local database. The local database is actually a postgres database normally hosted on AWS. It *might* be a MoM. The format of the queue entries is some key information plus a blob containing the raw message. Incoming messages may contain multiple sub messages (ie refer to multiple record updates) and the message processor will break thes up into multiple internal queue entries. It will not do much else.

There are restart scenarios: the server might restart, the client (ie the Message Processor) might restart. Both need to be handled cleanly. Messages are numbered but not necessarily contiguously. The Message Processor will at least need to remember the last processed message and request new messages from that plus one. That's a db save because if it crashes it won't have memory.

The Message Processor does not process the messages directly. It will probably split them up into several sub-messages (yet to nail down the message format but this seems likely) and save them into an internal queue. The internal queue will include the message number, date stamp and a blob containing the JSON body of the message.

##SalesForce Tables
<img src="AndrewTables.jpg" width="1000">

<img src="SalesForceTables.png" width="1000">

The Investor Fund Transaction is like the Account Summary and Investment Order, they all extend a 'virtul' parent, which means they *ought* to extend one but it doesn't exist. The goal is to get these to a flat single table which eliminates duplicate fields but contains potentially empty fields when those fields belong to a different 'type'.

---
#Queuing Decisions

The choice comes down to using Amazon's SQS or ActiveMQ both behind a JMS API, specifically Spring's jacket for it, so the underlying mechanism should have little effect on the software design. Except for the caveat that SQS is inclined to deliver duplicate messges and out-of-order messages on rare occaisions. This means the message receiver has to cater for that possibility (but not with ActiveMQ). So assume ActiveMQ for now but keep an eye on SQS.

[SQS tutorial (lite)](https://dzone.com/articles/aws-sqs-and-spring-jmsintegration)
[Setting up ActiveMQ in AWS](https://github.com/compomics/compomics-crowd/wiki/Setting-up-ActiveMQ-in-AWS)
[ActiveMQ powered by Bitnami](https://aws.amazon.com/marketplace/pp/B01K0IWOQO) This is a prepackaged AWS ActiveMQ solution

MessageReceiver only needs to implement javax.jms.MessageListener from /org/apache/geronimo/specs/geronimo-jms_1.1_spec/1.1.1/geronimo-jms_1.1_spec-1.1.1.jar, ie doesn't need the rest of the JMS dependencies.




